<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Dane z MQTT</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
      margin: 0;
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
    }

    .button-container {
      text-align: center;
      margin-bottom: 20px;
    }

    button {
      margin: 0 10px;
      padding: 10px 20px;
      background-color: #007BFF;
      border: none;
      border-radius: 5px;
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #0056b3;
    }

    .section {
      max-width: 1500px;
      margin: 0 auto 40px;
      display: none;
    }

    .filter-panel {
      background-color: #ffffff;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      display: none;
      max-width: 800px;
      margin: 0 auto 20px;
    }

    .chart-wrapper {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      overflow-x: auto;
    }

    canvas {
      width: 100% !important;
      height: 450px !important;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background-color: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      border-radius: 10px;
      overflow: hidden;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
    }

    th {
      background-color: #007BFF;
      color: white;
    }

  
  </style>
</head>
<body>
  <h1>Dane z MQTT</h1>
  <div style="text-align: center; margin-bottom: 20px;">
    <button onclick="toggleFilterPanel()" style="padding: 10px 20px; font-size: 16px;">ğŸ” PokaÅ¼ / Ukryj filtry</button>
  </div>

  <div id="filter-panel" style="display: none; text-align: center; margin-bottom: 20px;">
    <div style="display: inline-flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px;">
      <label>Od: <input type="datetime-local" id="fromTime"></label>
      <label>Do: <input type="datetime-local" id="toTime"></label>
      <button onclick="applyManualFilter()">âœ… Filtruj</button>
    </div>

    <div>
      <button onclick="setQuickFilter(1)">ğŸ• 1 min</button>
      <button onclick="setQuickFilter(5)">ğŸ•” 5 min</button>
      <button onclick="setQuickFilter(15)">ğŸ•– 15 min</button>
    </div>
  </div>

  <div class="button-container">
    <button onclick="toggleSection('chart-container')">ğŸ“ˆ Wykres napiÄ™Ä‡ i prÄ…du</button>
    <button onclick="toggleSection('power-chart-container')">âš¡ Wykresy mocy</button>
    <button onclick="toggleSection('table-container')">ğŸ“‹ Tabela danych</button>
	 <button onclick="exportToCSV()">ğŸ’¾ Eksport do CSV</button>
  </div>

  <!-- Wykres napiÄ™cia i prÄ…du -->
  <div class="section" id="chart-container">
    <div class="chart-wrapper">
      <canvas id="mqttChart"></canvas>
    </div>
  </div>


  <!-- Wykres mocy -->
  <div class="section" id="power-chart-container">
    <div class="chart-wrapper">
      <canvas id="powerChart"></canvas>
    </div>
  </div>

  <!-- Tabela -->
  <div class="section" id="table-container">
    <div class="chart-wrapper">
      <table>
        <thead>
          <tr>
            <th>Czas</th>
            <th>PrÄ…d - Halogeny (A)</th>
              <th>PrÄ…d - LEDy (A)</th>
              <th>NapiÄ™cie (V)</th>
              <th>Moc Halogeny (W)</th>
              <th>Moc LEDy (W)</th>
          </tr>
        </thead>
        <tbody id="dataTableBody">
          <!-- dane bÄ™dÄ… tu -->
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let mqttChart, powerChart;
    let filterFrom = null;
    let filterTo = null;
    let filterDurationMinutes = 1440;  //domyÅ›lny czas filtra 24h 
    let manualFilterActive = false; 

    function updateStatusIndicators(data) {
  // Sprawdzamy, czy dane zawierajÄ… current1, current2, oba lub Å¼aden
  const hasCurrent1 = data.some(entry => entry.current1 !== undefined || entry.current !== undefined);
  const hasCurrent2 = data.some(entry => entry.current2 !== undefined && entry.current2 !== 0);

  const indicator1 = document.getElementById('indicator-current1');
  const indicator2 = document.getElementById('indicator-current2');
  const indicatorBoth = document.getElementById('indicator-both');

  indicator1.classList.remove('active');
  indicator2.classList.remove('active');
  indicatorBoth.classList.remove('active');

  if (hasCurrent1 && hasCurrent2) {
    indicatorBoth.classList.add('active');
  } else if (hasCurrent1) {
    indicator1.classList.add('active');
  } else if (hasCurrent2) {
    indicator2.classList.add('active');
  }
}

	
	
    function toggleFilterPanel() {
      const panel = document.getElementById("filter-panel");
      panel.style.display = panel.style.display === "none" ? "block" : "none";
    }

    function updateFilterWindow() {
      if (!manualFilterActive) {
        filterTo = new Date();
        filterFrom = new Date(filterTo.getTime() - filterDurationMinutes * 60 * 1000);

        // Ustaw inputy daty aby byÅ‚y widoczne w UI
        document.getElementById("fromTime").value = filterFrom.toISOString().slice(0,16);
        document.getElementById("toTime").value = filterTo.toISOString().slice(0,16);
      }
      // jeÅ›li jest manualny filtr, nie zmieniamy go tutaj, aktualizuje siÄ™ tylko fetchDataAndUpdate()
    }

    function clearFilter() {
      manualFilterActive = false;
      filterFrom = null;
      filterTo = null;
      document.getElementById("fromTime").value = '';
      document.getElementById("toTime").value = '';
      fetchDataAndUpdate();
    }

    function applyManualFilter() {
      const fromInput = document.getElementById("fromTime").value;
      const toInput = document.getElementById("toTime").value;

      if (fromInput && toInput) {
        filterFrom = new Date(fromInput);
        filterTo = new Date(toInput);
        manualFilterActive = true;
      } else {
        manualFilterActive = false;
        filterFrom = null;
        filterTo = null;
      }
      fetchDataAndUpdate();
    }

    function setQuickFilter(minutes) {
      filterDurationMinutes = minutes;
      manualFilterActive = false; // szybkie filtry korzystajÄ… z ruchomego okna
      updateFilterWindow();
      fetchDataAndUpdate();
    }

    function toggleSection(id) {
      document.querySelectorAll('.section').forEach(div => {
        if (div.id === id) {
          div.style.display = div.style.display === 'block' ? 'none' : 'block';
        } else {
          div.style.display = 'none';
        }
      });
    }

 
async function fetchDataAndUpdate() {
  updateFilterWindow();

  try {
    // Pobierz nowe dane z API
    const res = await fetch('https://proj1-2.onrender.com/api/data');
    const newData = await res.json();
    // Pobierz stare dane z localStorage
    const savedData = JSON.parse(localStorage.getItem('mqttData')) || [];
    // PoÅ‚Ä…cz dane i usuÅ„ duplikaty (wg timestamp)
    const combinedData = [...newData, ...savedData].filter((entry, index, self) =>
      index === self.findIndex(e => e.timestamp === entry.timestamp)
    );

    // Filtruj dane (24h + aktualne filtry czasowe)
    const now = new Date();
   let filteredData = combinedData.filter(entry => {
  const entryDate = new Date(entry.timestamp);
  const isWithin24h = (now - entryDate) <= 24 * 60 * 60 * 1000;

  if (filterFrom && filterTo) {
    return isWithin24h && entryDate >= filterFrom && entryDate <= filterTo;
  }

  return isWithin24h;
});

    // Posortuj od najnowszych
    filteredData.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    // Zapisz do localStorage
    localStorage.setItem('mqttData', JSON.stringify(filteredData));

    const timestamps = [];
    const currents1 = [];
    const currents2 = [];
    const voltages = [];
    const power1 = [];
    const power2 = [];

    const tableBody = document.getElementById('dataTableBody');
    tableBody.innerHTML = '';

    [...filteredData].reverse().forEach(entry => {
      const entryDate = new Date(entry.timestamp);
      const time = entryDate.toLocaleTimeString();
      const voltage = entry.voltage || (entry.voltage1 + entry.voltage2) || 0;
      const current1 = entry.current1 || entry.current || 0;
      const current2 = entry.current2 || 0;
      const p1 = (voltage * current1).toFixed(3);
      const p2 = (voltage * current2).toFixed(3);

      timestamps.push(time);
      currents1.push(parseFloat(current1));
      currents2.push(parseFloat(current2));
      voltages.push(parseFloat(voltage));
      power1.push(parseFloat(p1));
      power2.push(parseFloat(p2));

      // Aktualizuj tabelÄ™
      const row = `<tr>
        <td>${time}</td>
        <td>${current1.toFixed(3)}</td>
        <td>${current2.toFixed(3)}</td>
        <td>${voltage.toFixed(3)}</td>
        <td>${p1}</td>
        <td>${p2}</td>
      </tr>`;
      tableBody.innerHTML += row;
    });

     // OpÃ³Åºnienie current2 o 6 prÃ³bek
    const delay = 1;
    const delayedCurrents2 = Array(delay).fill(null).concat(currents2.slice(0, currents2.length - delay));

    // Aktualizuj wykresy
    updateCharts(timestamps, currents1, delayedCurrents2, voltages, power1, power2);

  } catch (error) {
    console.error('BÅ‚Ä…d pobierania danych:', error);
  }
}

// Pomocnicza funkcja do aktualizacji wykresÃ³w
function updateCharts(timestamps, currents1, currents2, voltages, power1, power2) {
  if (!mqttChart) {
    mqttChart = new Chart(document.getElementById('mqttChart'), {
      type: 'line',
      data: {
        labels: timestamps,
        datasets: [
          { label: 'PrÄ…d - Halogeny (A)', data: currents1, borderColor: '#ff0099', fill: false },
          { label: 'PrÄ…d - LEDy (A)', data: currents2, borderColor: '#009999', fill: false },
          { label: 'NapiÄ™cie (V)', data: voltages, borderColor: '#00ff00', fill: false }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false }
    });
  } else {
    mqttChart.data.labels = timestamps;
    mqttChart.data.datasets[0].data = currents1;
    mqttChart.data.datasets[1].data = currents2;
    mqttChart.data.datasets[2].data = voltages;
    mqttChart.update();
  }

  if (!powerChart) {
    powerChart = new Chart(document.getElementById('powerChart'), {
      type: 'line',
      data: {
        labels: timestamps,
        datasets: [
          { label: 'Moc Halogeny (W)', data: power1, borderColor: '#cc33cc', fill: false },
          { label: 'Moc LEDy (W)', data: power2, borderColor: 'orange', fill: false }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false }
    });
  } else {
    powerChart.data.labels = timestamps;
    powerChart.data.datasets[0].data = power1;
    powerChart.data.datasets[1].data = power2;
    powerChart.update();
  }
}

// Funkcja eksportu do CSV (wywoÅ‚ywana przez przycisk)
function exportToCSV() {
  const data = JSON.parse(localStorage.getItem('mqttData')) || [];
  
  // Filtruj zgodnie z aktywnymi filtrami
  const filteredData = data.filter(entry => {
    if (!filterFrom && !filterTo) return true;
    const entryDate = new Date(entry.timestamp);
    return (!filterFrom || entryDate >= filterFrom) && (!filterTo || entryDate <= filterTo);
  });

  // NagÅ‚Ã³wki CSV
  const headers = ["Timestamp", "PrÄ…d - Halogeny (A)", "PrÄ…d - LEDy (A)", "Voltage (V)", "Moc - Halogeny (W)", "Moc - LEDy (W)"];

  // Funkcja formatujÄ…ca czas do 'YYYY-MM-DD HH:mm:ss'
  function formatDateTime(date) {
    const pad = (n) => n.toString().padStart(2, '0');
    return date.getFullYear() + '-' + pad(date.getMonth()+1) + '-' + pad(date.getDate()) + ' ' +
           pad(date.getHours()) + ':' + pad(date.getMinutes()) + ':' + pad(date.getSeconds());
  }
  
  // Generuj wiersze
  const rows = filteredData.map(entry => {
    const time = formatDateTime(new Date(entry.timestamp));
    const voltage = entry.voltage || (entry.voltage1 + entry.voltage2) || 0;
    const current1 = entry.current1 || entry.current || 0;
    const current2 = entry.current2 || 0;
    const p1 = (voltage * current1).toFixed(3);
    const p2 = (voltage * current2).toFixed(3);
    return `"${time}",${current1.toFixed(3)},${current2.toFixed(3)},${voltage.toFixed(3)},${p1},${p2}`;
  });

  // TwÃ³rz plik CSV
  const csvContent = [headers.join(','), ...rows].join('\n');
  const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  
  // Automatyczne pobieranie
  const link = document.createElement('a');
  link.href = url;
  link.download = `power_data_${new Date().toISOString().slice(0, 10)}.csv`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);

  // Komunikat o liczbie wyeksportowanych rekordÃ³w
  alert(`Eksportowano ${filteredData.length} rekordÃ³w.`);
}

// Inicjalizacja - czyszczenie starych danych przy Å‚adowaniu strony
window.addEventListener('load', () => {
  const savedData = JSON.parse(localStorage.getItem('mqttData')) || [];
  const now = new Date();
  const freshData = savedData.filter(entry => 
    (now - new Date(entry.timestamp)) <= 24 * 60 * 60 * 1000
  );
  localStorage.setItem('mqttData', JSON.stringify(freshData));
  fetchDataAndUpdate();
});

    // Inicjalizacja: ustaw domyÅ›lny filtr i odÅ›wieÅ¼ dane
 
    setInterval(fetchDataAndUpdate, 1000);
  </script>
</body>
</html>
